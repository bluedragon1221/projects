-- Code generated by Rust Lua interface. DO NOT EDIT.

    local ffi = require("ffi")

    ffi.cdef[[
    



            typedef struct {
                    const int32_t x;
    const int32_t y;
    const char * direction;
            } karel__Karel;
            
int32_t make_karel(
        karel__Karel**);
int32_t __gc_make_karel(
        karel__Karel*);

    ]]

    local rust = ffi.load('target/debug/libkarel.so')

    local M = {}

    

local __const_c_typename___string_ptr = ffi.typeof("const char *[?]")
local __c_function_argument___string_ptr = ffi.typeof("const char *[?]")
local __c_mut_function_argument___string_ptr = ffi.typeof("char *[?]")


local __const_c_typename_int32_t = ffi.typeof("const int32_t[?]")
local __c_function_argument_int32_t = ffi.typeof("int32_t[?]")
local __c_mut_function_argument_int32_t = ffi.typeof("int32_t[?]")


local __typename_Karel = ffi.metatype("karel__Karel", {})
local __const_c_typename_Karel = ffi.typeof("const karel__Karel[?]")
local __c_function_argument_Karel = ffi.typeof("const karel__Karel*[?]")
local __c_mut_function_argument_Karel = ffi.typeof("karel__Karel*[?]")

function M.make_karel(
    )
    local __typeof = __c_mut_function_argument_Karel
    local __ret_ptr = __typeof(1, {})
    local status = rust.make_karel(
        __ret_ptr
    )
    if status ~= 0 then
        error("make_karel failed with status "..status)
    end
    local __ret = __ret_ptr[0]
    ffi.gc(__ret, rust.__gc_make_karel)
    local f = function(value)
                return {
                    x = (function(value) return value end)(value.x), y = (function(value) return value end)(value.y), direction = (ffi.string)(value.direction)
                }
            end
    return f(__ret)
end


    return M
    
